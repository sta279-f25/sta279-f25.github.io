---
title: "Exam 2 review"
format: html
editor: source
---

Below are questions to help you study for Exam 2. These are some examples of the kinds of questions I might ask.

* This is not a practice exam. There will be fewer questions on the actual exam.
* The questions cover most, but not all, possible material for the exam.
* The distribution of questions here is not necessarily reflective of the distribution of questions on the actual exam.

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
library(tidyverse)
```


# Strings and regular expressions

## Example 1

Consider the following strings:

```{r, echo=F}
strings <- c(
  "George Washington: February 22, 1732",
  "Thomas Jefferson: April 13, 1743",
  "Abraham Lincoln: February 12, 1809",
  "Theodore Roosevelt: October 27, 1858"
)

strings
```

For each question below, fill in the R code to produce the desired output.

1.

**Solution:**

```{r}
str_extract(strings, ".+(?=:)")
```

2.


**Solution:**

```{r}
str_extract(strings, "(?<=: ).+")
```

3.

**Solution:**

```{r}
str_extract(strings, "(?<=\\s).+(?=:)")
```

4.

**Solution:**

```{r}
str_extract(strings, "(?<=, ).+")
```

## Example 2

Consider the following strings:

```{r, echo=F}
strings <- c("apple", "banana", "canteloupe", "durian",
             "eggplant", "french fries", "goat cheese",
             "pizza", "99 red balloons", "101 dalmatians",
             "route 66")
```

```{r}
strings
```


For each question below, fill in the R code to produce the desired output.

5.

**Solution:**

```{r}
str_subset(strings, "\\d+")
```

6.

**Solution:**

```{r}
str_subset(strings, "^\\d+")
```

7.

**Solution:**

```{r}
str_subset(strings, "a")
```

8.

**Solution:**

```{r}
str_subset(strings, "\\s")
```

9.

**Solution:**

```{r}
str_subset(strings, "(.)\\1{1}")
```

## Example 3

Suppose you receive a vector containing the following email addresses:

```{r}
emails <- c("evansc@wfu.edu",
            "dalzelnm@wfu.edu",
            "heplersa@wfu.edu")
```

10. Fill in the following code to produce the desired output:

**Solution:**

```{r}
str_extract(emails, "^.+(?=@)")
```

## Example 4

You have a folder with the following filenames:

```{r}
filenames <- c(".bash_profile",
               "workspace.doc",
               "img0912.jpg",
               "updated_img0912.png",
               "documentation.html",
               "favicon.gif",
               "access.lock")
```


11. Fill in the following code to produce the desired output:

**Solution:**

```{r}
str_subset(filenames, "(gif|png|jpg)")
```

## Example 5

Consider the following string:

```{r}
ex_str <- "The kurtosis is defined by the equation $\\mu_4/\\sigma^4$, 
where $\\mu_4$ is the fourth central moment 
and $\\sigma$ is the standard deviation."
```

12. Fill in the following code to produce the desired output:

**Solution:**

```{r}
str_extract_all(ex_str, "\\$[^\\$]+\\$")
```

## Example 6

Here is another small dataset, `ex_df`, which has a single column (`faculty`):

```{r, include=F}
ex_df <- data.frame(faculty = c("Rob Erhardt, Professor: MAN 343",
                "Daniel Beavers, Associate Professor: MAN 337",
                "Kenneth Berenhaut, Professor: MAN 379",
                "Leonardo Cella, Assistant Professor: MAN 344",
                "Lucy D'Agostino McGowan, Assistant Professor: MAN 342",
                "Nicole Dalzell, Associate Teaching Professor: MAN 338"))
```

```{r}
ex_df
```

13. Write code to produce the following output using `ex_df`:

**Solution:**

Option 1:

```{r}
ex_df |>
  mutate(name = str_extract(faculty, ".+(?=,)"),
         position = str_extract(faculty, "(?<=, ).+(?=:)"),
         office = str_extract(faculty, "(?<=: ).+")) |>
  select(-faculty)
```



Option 2:

```{r}
ex_df |>
  separate_wider_regex(faculty,
                       patterns = c(
                         name = ".+",
                         ", ",
                         position = ".+",
                         ": ",
                         office = ".+"
                       ))
```


# Web scraping

## Example 1

Consider the following portion of a web page:

<h1> STA 279 </h1>

<p> 
  Welcome to STA 279! This is a 16-week course offered at Wake Forest University, which meets 3 hours each week. The syllabus can be found <a href='https://sta279-f25.github.io/about/'>here</a> 
</p>

<p>
  Below are some useful dates for the semester:
   <table>
  <tr>
    <td>Exam 1</td>
    <td>March 1</td>
  </tr>
  <tr>
    <td>Exam 2</td>
    <td>April 12</td>
  </tr>
</table> 
</p>

Now here is the source HTML for that simple web page:

```
<h1> STA 279 </h1>

<p> 
  Welcome to STA 279! 
  This is a 16-week course offered at Wake Forest University, 
  which meets 3 hours each week. 
  The syllabus can be found 
  <a href='https://sta279-f25.github.io/about/'>here</a> 
</p>

<p>
  Below are some useful dates for the semester:
   <table>
  <tr>
    <td>Exam 1</td>
    <td>March 1</td>
  </tr>
  <tr>
    <td>Exam 2</td>
    <td>April 12</td>
  </tr>
</table> 
</p>
```

14. Suppose that the url for this page is "https://fake_web_page.html". Write code that will import the table of exam dates into R, as a data frame.

**Solution:**

```{r, eval=F}
read_html("https://fake_web_page.html") |>
  html_element("table") |>
  html_table()
```


15. Suppose that the url for this page is "https://fake_web_page.html". What will the following code return?

```{r, eval=F}
read_html("https://fake_web_page.html") |>
  html_element("h1") |>
  html_text2() |>
  str_extract("\\d+")
```

**Solution:** 279

## Example 2

Consider the following short portion of a web page, with URL `https://fake_page.html`.

```
<div class="mesa">
  <span>
    <p> Hello! </p>
  </span>
  
  <p class="small"> Welcome to STA 279! </p>
  
  <span>
    <p class="small"> Room: Carswell 102 </p>
  </span>
  
  <span>
    <h3 class="small"> Grading policy </h3>
  </span>
  
  <span>
    <p class="small"> Exam dates </p>
  </span>
</div>
```

16. Write code in R that will extract the following string from this web page:

```{r, include=F}
res_strs <- c("Carswell 102")
```

```{r, echo=F}
res_strs
```

**Solution:**

```{r, eval=F}
read_html("https://fake_page.html") |>
  html_element("span > p.small") |>
  html_text2()
```


17. Using your code from the previous question, write a short function with the following specifications:
    * Input: `url` the URL for a web page with the same format as above
    * Output: the building and room number for the class, scraped from the web page
    
**Solution:**

```{r, eval=F}
get_room <- function(url){
  read_html(url) |>
  html_element("span > p.small") |>
  html_text2()
}
```


18. Suppose that we have the web pages for 20 different classes at Wake Forest, all of which have the same format as shown above, but which take places in different rooms. The URLS are stored in a vector:

```{r, include=F}
class_urls <- paste0("https://fake_page_", 1:20, ".html")
```

```{r}
class_urls
```

Using your answers to the previous questions, iterate over this vector of URLs to produce a vector containing the building and room number for each class.

**Solution:**

```{r, eval=F}
map_chr(class_urls, get_room)
```

I'm using `map_chr` here since I want to return a vector rather than a list. If I asked this question on the exam, I would also accept a solution with `map` in place of `map_chr`.


## Polite web scraping

19. Why is it important to be polite when scraping from a website?

20. What are the features of polite web scraping that we discussed in class?


# SQL

Here is a rough summary of what you should know from the SQL unit:

* Pieces of a SQL query you should know:
  * `SELECT`
  * `FROM`
  * `JOIN` (an inner join) and `LEFT JOIN` (a left join)
  * `WHERE`
  * `GROUP BY`
  * `HAVING`
  * `ORDER BY`
  * `LIMIT`
* You should also know the order in which queries must be written
* Other functions to know for queries:
  * `DISTINCT`
  * Summary functions like `SUM`, `AVG`, `MIN`, `MAX`, `COUNT`
  * `LIKE`, and the wildcards `%` and `_`
  * `CASE`
* The function of primary and foreign keys, and the constraints they place on tables
* How to read and interpret an ERD
* You should be able to read and interpet the results of `DESCRIBE`, `ALTER TABLE`, and `INSERT INTO` statements. You will *not* have to write these statements
* Subqueries

## Practice with SQL queries

Here is a small table in a SQL database. The name of the table is `small_penguins`.

```{r, echo=F, message=F, warning=F}
library(tidyverse)
library(palmerpenguins)

set.seed(3)

sub_data <- penguins |>
  slice_sample(n=10) |>
  select(species, island, bill_length_mm, bill_depth_mm)

sub_data |>
  data.frame()
```

```{r, include=F}
conn <- DBI::dbConnect(duckdb::duckdb())
DBI::dbWriteTable(conn, "small_penguins", sub_data)
```


In each of the following examples, write a SQL query to produce the desired output from `small_penguins`.

21. Output:

```{r, echo=F}
sub_data |>
  count(species, island) |>
  data.frame()
```

```{sql connection=conn}
SELECT species, island, COUNT(*) as n
FROM small_penguins
GROUP BY species, island;
```

22. Output:

```{r, echo=F}
sub_data |>
  group_by(island, species) |>
  summarize(mean_length = mean(bill_length_mm, na.rm=T)) |>
  data.frame()
```

```{sql connection=conn}
SELECT island, species, AVG(bill_length_mm) AS mean_length
FROM small_penguins
GROUP BY island, species;
```

23. Output:

```{r, echo=F}
sub_data |>
  mutate(bill_ratio = bill_length_mm/bill_depth_mm) |>
  data.frame()
```

```{sql connection=conn}
SELECT species, island, bill_length_mm, bill_depth_mm,
  bill_length_mm/bill_depth_mm AS bill_ratio
FROM small_penguins;
```


24. Output:

```{r, echo=F}
sub_data |>
  filter(species == "Adelie", 
         island == "Dream") |>
  data.frame()
```

```{sql connection=conn}
SELECT species, island, bill_length_mm, bill_depth_mm
FROM small_penguins
WHERE species = 'Adelie' AND island = 'Dream';
```


## Joins

In each of the following questions, write a SQL query to produce the desired output from the two input tables

25.

```{r, echo=F}
df1 <- data.frame(
  id = c(1, 2, 3),
  x = c(7, 9, 13)
)

df2 <- data.frame(
  id = c(1, 2, 4),
  y = c(10, 12, 14)
)
```

```{r}
df1

df2
```

```{r, include=F}
DBI::dbWriteTable(conn, "df1", df1)
DBI::dbWriteTable(conn, "df2", df2)
```



Output:

```{r, echo=F}
df1 |>
  left_join(df2, join_by(id))
```

```{sql connection=conn}
SELECT df1.id, x, y
FROM df1 
LEFT JOIN df2 ON df1.id = df2.id;
```


26.

```{r}
df1

df2
```


Output:

```{r, echo=F}
df1 |>
  inner_join(df2, join_by(id))
```

```{sql connection=conn}
SELECT df1.id, x, y
FROM df1 
JOIN df2 ON df1.id = df2.id;
```

## More practice with SQL queries

The `nycflights13` package in R contains several datasets describing flights from NY airports in 2013, including the `airports` and `weather` tables. 

The `airports` table has one row for each different airport in the database. There are a total of 1458 rows and 8 columns in the `airports` table; here are a few random rows from the table, showing the relevant columns for this question:

```{r, echo=F, message=F, warning=F}
library(nycflights13)

airports |>
  select(faa, name) |>
  slice_sample(n=5) |>
  data.frame()
```

The `weather` table has one row for each date-time, for each of the three NY airports (EWR, JFK, LGA), and records a variety of weather variables at each time for each location. Here are a few random rows from the table, showing the relevant columns for this question:

```{r, echo=F}
weather |>
  select(origin, month, temp, humid) |>
  slice_sample(n=5) |>
  data.frame()
```

The `weather` table uses a 3-character FAA code to identify each airport. It does *not* include the full name for the airports. 

We would like to produce a table with the mean temperature, and humidity for each month, for each of the 3 NYC airports in the database. The output table should also include the full name of each airport. Here is what the output table looks like:

```{r, echo=F}
weather |>
  group_by(origin, month) |>
  summarize(mean_temp = mean(temp, na.rm=T),
            mean_humid = mean(humid, na.rm=T)) |>
  inner_join(airports, join_by(origin == faa)) |>
  select(origin, name, month, mean_temp, mean_humid) |>
  data.frame()
```

27. Write a SQL query to produce the desired results.

```{r, include=F}
DBI::dbWriteTable(conn, "weather", nycflights13::weather)
DBI::dbWriteTable(conn, "airports", nycflights13::airports)
```

**Solution:**

```{sql connection=conn}
SELECT weather.origin, name, month, 
  AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
FROM weather
JOIN airports ON weather.origin = airports.faa
GROUP BY origin, name, month
ORDER BY origin, month;
```

28. How would you modify your above query to keep only the rows in the results for which the mean temperature is at least 60?

**Solution:**

```{sql connection=conn}
SELECT weather.origin, name, month, 
  AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
FROM weather
JOIN airports ON weather.origin = airports.faa
GROUP BY origin, name, month
HAVING mean_temp >= 60
ORDER BY origin, month;
```

29. How would you modify your above query to keep only the rows for which the mean temperature is the highest average temperature?

**Solution:** This is quite tricky, and requires us to combine some queries. 

Assuming that we want to get the highest average monthly temperature for each airport, a partial answer is the following, though note that this only gives us the origin and max mean temperature columns:

```{sql connection=conn}
SELECT origin, MAX(mean_temp)
FROM 
  (
  SELECT weather.origin, name, month, 
    AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
  FROM weather
  JOIN airports ON weather.origin = airports.faa
  GROUP BY origin, name, month
  ORDER BY origin, month
  ) 
GROUP BY origin;
```

This partial solution uses a subquery, and this is about the level of difficulty I would put on the exam.

A full solution is beyond the scope of the exam, and I think requires us to use either multiple subqueries, or to create an intermediate view/table. Here is one solution which uses two subqueries:

```{sql connection=conn}
SELECT weather.origin, name, month, 
    AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
FROM weather
JOIN airports ON weather.origin = airports.faa
GROUP BY origin, name, month
HAVING (origin, mean_temp) IN
  (SELECT origin, MAX(mean_temp)
    FROM 
    (
      SELECT weather.origin, name, month, 
        AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
      FROM weather
      JOIN airports ON weather.origin = airports.faa
      GROUP BY origin, name, month
      ORDER BY origin, month
  ) 
  GROUP BY origin
 );
```

However, the problem with this solution is that it requires us to create the results from question 27 **twice**, which is quite inefficient. Instead, we could store the results from question 27, then use these results. Here is what those queries might look like (again, I don't expect you to be able to do this part for the exam):

```{sql connection=conn}
CREATE VIEW monthly_weather AS
  (SELECT weather.origin, name, month, 
    AVG(temp) AS mean_temp, AVG(humid) AS mean_humid
  FROM weather
  JOIN airports ON weather.origin = airports.faa
  GROUP BY origin, name, month);
```

```{sql connection=conn}
SELECT * 
FROM monthly_weather
WHERE (origin, mean_temp) IN
  (SELECT origin, MAX(mean_temp)
   FROM monthly_weather
   GROUP BY origin);
```



## Conceptual questions

30. What are the differences between `SELECT` in a SQL query, and the `select` function from `dplyr` in R?

**Solution:** The `select` function from the `dplyr` package has one function: selecting columns from the data frame. We don't use the `select` function to create new columns or summary statistics -- those roles are performed by, respectively, the `mutate` and `summarize` functions. However, in SQL `SELECT` does all of this. Choosing existing columns, creating a new column, or creating aggregates of existing columns all happen with `SELECT`.

31. Suppose you are managing a database for a hospital. List four different tables which might be included in the hospital database. For each table:
  * Describe what information would be included (what would a row represent? what would be some of the columns?)
  * Is there a natural primary key for the table? What column or set of columns would form that primary key?
  * Are there any columns in the table that would be foreign keys for other tables in the database?
  
**Solution:** There is not just one right answer here. Here is one possible answer.

Tables:

* `Patients`: information on each patient that has been treated at the hospital
  * Primary key: 
    * `MRN` (medical record number), a unique identifier assigned to each patient in the healthcare organization
  * Other columns
    * Date of birth
    * Sex
    * Insurance
    * Address
    * Phone number
* `Staff`: information on doctors, nurses, etc. who have worked at the hospital
  * Primary key:
    * `ID` employee ID
  * Other columns
    * Role
    * Employment status
    * Age
    * Area(s) of specialty
    * Department
* `Pharmacy`: information on drugs prescribed to patients in the hospital
  * Foreign keys:
    * `PatientID` refers to `MRN` in the `Patients` table. Patient to whom drug was prescribed
    * `StaffID` refers to `ID` in the `Staff` table. Staff member who prescribed the drug
  * Other columns
    * Date prescribed
    * Drug
    * Dosage
* `Visits`:  information on each visit
  * Foreign keys:
    * `PatientID` refers to `MRN` in the `Patients` table
  * Other columns
    * Check-in time
    * Check-out time
    * Reason for visit
    

# Practice with function scoping

32. What will be the output of the following code?

```{r}
x <- 10
test_fun <- function(x = 11){
  return(x)
}
test_fun()
x
```

33. What will be the output of the following code?

```{r}
x <- 10
test_fun <- function(y = 11){
  return(x + 1)
}
test_fun()
x
```

34. What will be the output of the following code?

```{r}
x <- 10
test_fun <- function(y = 11){
  x <- x + 1
  return(x + 1)
}
test_fun()
x
```

35. What will be the output of the following code?

```{r}
x <- 10
test_fun <- function(x = 11){
  x <- x + 1
  return(x + 1)
}
test_fun()
x
```

36. What will be the output of the following code?

```{r}
x <- 10
test_fun <- function(x = 11){
  x <- x + 1
  return(x + 1)
}
x <- test_fun(x)
x
```

# Practice with lists

37. Create a list `x` in R such that:

* `x[[1]]` returns the function `mean`
* `x[[2]]` returns the function `sd`
* `x[[3]][[1]]` returns the vector `c(0, 1, 2)`
* `x[[3]][[2]]` returns a function which calculates the cube root of a vector

**Solution:**

```{r}
x <- list(mean, sd, list(c(0, 1, 2), 
                         function(y) y^(1/3)))

x[[1]](1:10)
x[[2]](1:10)
x[[3]][[1]]
x[[3]][[2]](c(8, 27, 64))
```



```{r, include=F}
DBI::dbDisconnect(conn)
```




