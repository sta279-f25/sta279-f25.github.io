---
title: "Exam 1 review solutions"
format: html
editor: source
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, error = TRUE)
```


# Practice with loops in R

1. What will the following code return when you run it in R?

```{r}
output <- rep(NA, 10)
for(i in 1:5){
  output[i] <- i
}

output[6]
```

2. What will the following code return when you run it in R?

```{r}
output <- rep(0, 10)
for(i in 1:10){
  output[i] <- i
}

output[6]
```

3. What will the following code return when you run it in R?

```{r}
output <- rep(0, 10)
for(i in 1:10){
  output[i] <- i
}

output[11]
```

4. What will the following code return when you run it in R?

```{r}
output <- rep(1, 10)
for(i in 2:10){
  output[i] <- i + output[i-1]
}

output[5]
```

5. What will the following code return when you run it in R?

```{r}
output <- rep(1, 10)
for(i in 2:10){
  output[i] <- i + output[i+1]
}

output[5]
```


# Practice with functions

## Standard deviation

The *sample standard deviation* of numbers $x_1,...,x_n$ is given by 

$$\widehat{\sigma} = \sqrt{\frac{1}{n-1}\sum \limits_{i=1}^n (x_i - \bar{x})^2},$$

where $\bar{x} = \frac{1}{n} \sum \limits_{i=1}^n x_i$.

6. Write a function called `my_sd` which calculates the standard deviation of a vector in R.

```{r}
my_sd <- function(x){
  n <- length(x)
  if(n == 1){
    return(0)
  } else {
    return(sqrt(1/(n-1) * sum((x - mean(x))^2)))
  }
}

# checking that it works
my_sd(c(1,2,4))
sd(c(1,2,4))
```

## $\ell_p$ norm

The $\ell_p$ norm of a vector $x = (x_1,...,x_k)$ is given by

$$||x||_p = \left( \sum \limits_{i=1}^k |x_i|^p \right)^{1/p}$$

7. Write a function called `p_norm` in R, which takes two inputs: a vector `x`, and `p`, and returns $\ell_p(x)$. Make `p = 2` the default value (this corresponds to the usual Euclidean norm).

```{r}
p_norm <- function(x, p=2){
  (sum(abs(x)^p))^(1/p)
}

p_norm(c(1, 1, 1)) # = sqrt(3)
p_norm(c(1, 2, 3), 1) # = 6
```

## Kurtosis

Suppose we have a sample $X_1,...,X_n$ from some population distribution. We know that the mean describes the "center" of the distribution, the standard deviation is a measure of variability, and skewness describes the shape of the distribution. 

Another quantity we can calculate to describe a distribution is *kurtosis*, which describes how heavy the tails of the distribution are. The *sample kurtosis* is calculated by:

$$\dfrac{\frac{1}{n} \sum \limits_{i=1}^n (X_i - \bar{X})^4}{\left( \frac{1}{n} \sum \limits_{i=1}^n (X_i - \bar{X})^2 \right)^2} \ \ - \ \ 3$$

where $\bar{X}$ is the sample mean.

8. Write a function in R to calculate the sample kurtosis. Your function should take in one argument: a vector `x`.

```{r}
my_kurtosis <- function(x){
  mean((x - mean(x))^4)/(mean((x - mean(x))^2))^2 - 3
}
```

## Correlation

Suppose we have a sample $(X_1, Y_1),...,(X_n, Y_n)$ of $n$ observations collected on two variables, $X$ and $Y$. The strength of the linear relationship between $X$ and $Y$ is measured by their *correlation*, and the sample correlation is calculated with the following formula:


$$\dfrac{ \sum \limits_{i=1}^n (X_i - \bar{X})(Y_i - \bar{Y})}{\left( \sum \limits_{i=1}^n (X_i - \bar{X})^2 \right)^{1/2} \left( \sum \limits_{i=1}^n (Y_i - \bar{Y})^2 \right)^{1/2}}$$

9. Write a function in R to calculate the sample correlation. Your function should take in two arguments: a vector `x` and a vector `y`.

```{r}
my_corr <- function(x, y){
  sum((x - mean(x)) * (y - mean(y)))/( sqrt(sum((x - mean(x))^2)) * 
                                         sqrt(sum((y - mean(y))^2)) )
}
```


# Practice with probability simulations

Three players enter a room and a red or blue hat is placed on each personâ€™s head.
The color of each hat is determined by an **independent** coin toss (so, any combination of red and blue hats is possible). No communication of any sort is allowed, except for an initial strategy session before the game begins. Once they have had a chance to look at the other hats **but not their own**, the players must *simultaneously* guess the color of their own hats or pass. The players win the game if at least one person guesses correctly, and no one guesses incorrectly.

10. Here is one strategy: one player randomly guesses the color of their hat, while the other two players pass. Write a simulation to estimate the probability the players win the game (the true probability is 1/2).

```{r}
set.seed(91)

nsim <- 1000
results <- rep(NA, nsim)
for(i in 1:nsim){
  hats <- sample(c("red", "blue"), 3, replace=T)
  guesses <- c(sample(c("red", "blue"), 1), "pass", "pass")
  results[i] <- guesses[1] == hats[1]
}

mean(results)
```

11. Here is another strategy: if a player sees the same color on the other two hats, they guess the color they do not see. If a player sees different colors on the other two hats, they pass. For example: If players A, B, and C have hats red, blue, and blue respectively, then player A would guess red, player B would pass, and player C would pass. Write a simulation to estimate the probability the players win the game with this new strategy (the true probability is 3/4).

**Note:** For the exam, I am more interested in the logic of how you approach the simulation, than in your code syntax being perfect. Your code should be mostly correct, but a few minor errors isn't an issue.

```{r}
nsim <- 1000
results <- rep(NA, nsim)
for(i in 1:nsim){
  hats <- sample(c("red", "blue"), 3, replace=T)
  guesses <- rep(NA, 3)
  for(j in 1:3){
    if(length(unique(hats[-j])) == 1){
      guesses[j] <- ifelse(unique(hats[-j]) == "red", "blue", "red")
    } else {
      guesses[j] <- "pass"
    }
  }
  
  results[i] <- sum(guesses[guesses != "pass"] == hats[guesses != "pass"]) == 
    length(guesses[guesses != "pass"])
}

mean(results)
```


# Practice with data wrangling

## Writing code

In each of the questions below, write code to produce the output from the original data.

12. Original data:

```{r, echo=F, message=F, warning=F}
library(tidyverse)
library(palmerpenguins)

set.seed(3)

sub_data <- penguins |>
  slice_sample(n=10) |>
  select(species, island, bill_length_mm, bill_depth_mm)
```

```{r}
sub_data
```

Output:

```{r}
sub_data |>
  count(species, island)
```

13. Original data:

```{r}
sub_data
```

Output:

```{r}
sub_data |>
  group_by(island, species) |>
  summarize(mean_length = mean(bill_length_mm, na.rm=T))
```


14. Original data:

```{r}
sub_data
```

Output:

```{r}
sub_data |>
  mutate(bill_ratio = bill_length_mm/bill_depth_mm)
```


15. Original data:

```{r}
sub_data
```

Output:

```{r}
sub_data |>
  filter(species == "Adelie", 
         island == "Dream")
```


16. Original data:

```{r, echo=F}
ex_df <- data.frame(
  id = c(1, 2, 3),
  x_1 = c(3, 1, 4),
  x_2 = c(5, 8, 9),
  y_1 = c(0, 1, 2),
  y_2 = c(2, 7, 9)
)
```

```{r}
ex_df
```

Output:

```{r}
ex_df |>
  pivot_longer(cols = -id, names_to = c("group", "obs"), names_sep = "_")
```

17. Original data:

```{r, echo=F}
ex_df <- data.frame(
  id = c(1, 1, 2, 2, 3, 3),
  group = c("x", "y", "x", "y", "x", "y"),
  value = sample(1:6, replace=T)
)
```

```{r}
ex_df
```

Output:

```{r}
ex_df |>
  pivot_wider(id_cols = id, names_from = group, values_from = value)
```

## Joins

In each of the following questions, write code to produce the desired output from the two input datasets. The code may involve additional wrangling steps, beyond a join.

18.

```{r, echo=F}
df1 <- data.frame(
  id = c(1, 2, 3),
  x = c(7, 9, 13)
)

df2 <- data.frame(
  id = c(1, 2, 4),
  y = c(10, 12, 14)
)
```

```{r}
df1

df2
```


Output:

```{r}
df1 |>
  left_join(df2, join_by(id))
```


19.

```{r}
df1

df2
```


Output:

```{r}
df1 |>
  inner_join(df2, join_by(id))
```

20.

```{r, echo=F}
df1 = data.frame(
  a_x = 1,
  a_y = 2,
  b_x = 2,
  b_y = 3
)

df2 = data.frame(
  id = c("a", "b"),
  z = c(4, 5)
)
```

```{r}
df1

df2
```


```{r}
df1 |> 
  pivot_longer(cols = -c(), names_to = c("id", ".value"), names_sep = "_") |>
  left_join(df2, join_by(id))
```


## Reading data wrangling code

Here are two small datasets, `df1` and `df2`:

```{r, include=F}
set.seed(3)

df1 <- data.frame(id = 1:5, 
                  x = sample(1:10, 5, replace=T),
                  y = sample(1:10, 5, replace=T),
                  z = sample(1:10, 5, replace=T))

df2 <- data.frame(id = 3:6,
                  a = sample(1:10, 4, replace=T),
                  b = sample(1:10, 4, replace=T))
```

```{r}
df1

df2
```


For each of the following chunks of code, write down the output or explain why it will cause an error.


21.

```{r}
df1 |>
  left_join(df2, join_by(id))
```

22.

```{r}
df1 |>
  inner_join(df2, join_by(id))
```

23.

```{r}
df1 |>
  group_by(z) |>
  summarize(max_b = max(b))
```


24.

```{r}
df1 |>
  select(x, y) |>
  pivot_longer(cols = -id,
               names_to = "measurement",
               values_to = "value")
```

25.

```{r}
df1 |>
  select(id, x, y) |>
  pivot_longer(cols = -id,
               names_to = "measurement",
               values_to = "value") |>
  filter(id %in% c(1, 2, 3))
```

26.

```{r}
df1 |>
  left_join(df2, join_by(id)) |>
  mutate(new_var = x + a) |>
  group_by(z) |>
  summarize(mean_new_var = mean(new_var))
```


27.

```{r}
df1 |>
  left_join(df2, join_by(id)) |>
  mutate(new_var = x + a) |>
  group_by(z) |>
  summarize(mean_new_var = mean(new_var, na.rm=T)) |>
  summarize(mean_b = mean(b))
```



